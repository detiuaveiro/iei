<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>DHT11</title>
  <meta name="author" content="MÃ¡rio Antunes">

  <script src="js/plotly-3.1.0.min.js" charset="utf-8"></script>
  <script src="js/paho-mqtt-min.js" charset="utf-8"></script>
  <script src="js/predict.js" charset="utf-8"></script>
</head>

<body>

  <div id='plot' style='width:800px;height:400px;'></div>

  <script>
    let mqtt = new Paho.MQTT.Client('192.168.0.107', 9001, '');

    let trace_temp = {x:[],y: [],
      mode: 'lines+markers',
      type: 'scatter'
    };

    let trace_hum = {x:[],y: [],
      mode: 'lines+markers',
      type: 'scatter',
      yaxis: 'y2'
    };

    let data = [trace_temp, trace_hum];

    var layout = {
      title: {text: 'DHT11'},
      yaxis: {
        title: {
          text: 'Temperature'
        }
      },
      yaxis2: {
        title: {
          text: 'Humidity',
          font: {color: 'rgb(148, 103, 189)'}
        },
        tickfont: {color: 'rgb(148, 103, 189)'},
        overlaying: 'y',
        side: 'right'
      }
    };

    Plotly.newPlot('plot', data, layout);

    // set callback handlers
    mqtt.onConnectionLost = onConnectionLost;
    mqtt.onMessageArrived = onMessageArrived;

    let options = {timeout:3, onSuccess: onConnect};
    mqtt.connect(options);

    function onConnect(){
        console.log('Connected...');
        mqtt.subscribe('it/pico/dht11');
    }

    // called when the client loses its connection
    function onConnectionLost(responseObject) {
      if (responseObject.errorCode !== 0) {
        console.log("onConnectionLost:"+responseObject.errorMessage);
      }
    }

    // called when a message arrives
    function onMessageArrived(message) {
    let data;

    // 1. Parse the incoming JSON string
    try {
      // message.payloadString is expected to be a valid JSON string
      // e.g., {"ts": 1678886400000, "t": 25.5, "h": 45.2}
      data = JSON.parse(message.payloadString);
    } catch (e) {
      console.error("Failed to parse JSON:", e, message.payloadString);
      return; // Exit if JSON is invalid
    }

    // 2. Use the timestamp from the message payload (data.ts)
    // We assume 'data.ts' is a JS-compatible timestamp (milliseconds since epoch)
    let messageTime = new Date(data.ts*1000);

    console.log("onMessageArrived(" + message.destinationName + "):", data);

    // 3. Update the plot's X-axis range (Relayout)
    // This creates a 2-minute window centered on the new data point
    // (Note: This fixes a small bug in the original code's time logic)
    let olderTime = new Date(messageTime.getTime() - 60000); // 1 minute before
    let futureTime = new Date(messageTime.getTime() + 60000); // 1 minute after

    let minuteView = {xaxis: { type: 'date', range: [olderTime, futureTime] }};
    Plotly.relayout('plot', minuteView);

    // 4. Prepare the data update based on the topic
    let update;
    update = {
      x: [[messageTime]], // Use the timestamp from the message
      y: [[data.t]]       // Use the 't' (temp) value from the JSON
    };
    Plotly.extendTraces('plot', update, [0]); // Update trace 0
    update = {
      x: [[messageTime]], // Use the timestamp from the message
      y: [[data.h]]       // Use the 'h' (hum) value from the JSON
    };
    Plotly.extendTraces('plot', update, [1]); // Update trace 1
  }
  </script>
</body>
</html>
